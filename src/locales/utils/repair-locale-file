#!/bin/bash
# repair-locale-file

# Repairs i18n locale files to match base en.json key structure
# Preserves existing translations while adding missing keys
# Usage: ./repair-locale-file [-q] [-f] [-v] LOCALE_FILE
# Exit: 0 if repair succeeds, 1 if fails

QUIET=${QUIET:-0}
FILENAME_ONLY=${FILENAME_ONLY:-0}
VERBOSE=${VERBOSE:-0}

while getopts ":qfv" opt; do
  case $opt in
    q) QUIET=1 ;;
    f) FILENAME_ONLY=1 ;;
    v) VERBOSE=1 ;;
    \?) echo "Invalid option: -$OPTARG" >&2; exit 1 ;;
  esac
done
shift $((OPTIND -1))

LOCALE="$1"
[ -z "$LOCALE" ] && echo "Usage: $0 [-q] [-f] [-v] LOCALE_FILE" >&2 && exit 1
[ ! -f "$LOCALE" ] && echo "File not found: $LOCALE" >&2 && exit 1

OUTPUT="${LOCALE%.json}.transformed.json"

if ! jq -n --slurpfile base src/locales/en.json --slurpfile target "$LOCALE" '
def walk($base):
  . as $target |
  if type == "object" then
    $base | with_entries(
      .key as $k |
      .value as $v |
      {
        key: $k,
        value: ($target[$k] | if . == null then $v else walk($v) end)
      }
    )
  else
    if . == null then $base else . end
  end;

$target[0] | walk($base[0])
' > "$OUTPUT"; then
  [ $FILENAME_ONLY -eq 1 ] && echo "$LOCALE" && exit 1
  [ $QUIET -eq 1 ] && exit 1
  [ $VERBOSE -eq 1 ] && echo "Failed repairing $LOCALE"
  exit 1
fi

mv "$OUTPUT" "$LOCALE"
[ $VERBOSE -eq 1 ] && echo "Repaired $LOCALE"
exit 0
