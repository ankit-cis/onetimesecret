#!/bin/bash

# Repairs i18n locale files to match base en.json key structure
# Preserves existing translations while moving/adding keys
# Usage: ./repair-locale-file [-q] [-f] [-v] [-c] LOCALE_FILE
# -q: quiet mode
# -f: filename only output
# -v: verbose output
# -c: copy values from base file
# Exit: 0 if repair succeeds, 1 if fails

QUIET=${QUIET:-0}
FILENAME_ONLY=${FILENAME_ONLY:-0}
VERBOSE=${VERBOSE:-0}
COPY_VALUES=${COPY_VALUES:-0}

while getopts ":qfvc" opt; do
  case $opt in
    q) QUIET=1 ;;
    f) FILENAME_ONLY=1 ;;
    v) VERBOSE=1 ;;
    c) COPY_VALUES=1 ;;
    \?) echo "Invalid option: -$OPTARG" >&2; exit 1 ;;
  esac
done
shift $((OPTIND -1))

LOCALE="$1"
[ -z "$LOCALE" ] && echo "Usage: $0 [-q] [-f] [-v] [-c] LOCALE_FILE" >&2 && exit 1
[ ! -f "$LOCALE" ] && echo "File not found: $LOCALE" >&2 && exit 1

OUTPUT="${LOCALE%.json}.transformed.json"

jq_script='
def walk($base; $full_target):
  . as $target |
  if type == "object" then
    $base | with_entries(
      .key as $k |
      .value as $v |
      {
        key: $k,
        value: (
          if $k == "about" and $target[$k] == null and $full_target.about != null then
            $full_target.about
          elif $target[$k] != null then
            $target[$k] | walk($v; $full_target)
          else
            if '$COPY_VALUES' == 1 then $v else "" end
          end
        )
      }
    )
  else
    if . == null then (if '$COPY_VALUES' == 1 then $base else "" end) else . end
  end;

$target[0] | walk($base[0]; $target[0])
'

if ! jq -n --slurpfile base src/locales/en.json --slurpfile target "$LOCALE" "$jq_script" > "$OUTPUT"; then
  [ $FILENAME_ONLY -eq 1 ] && echo "$LOCALE" && exit 1
  [ $QUIET -eq 1 ] && exit 1
  [ $VERBOSE -eq 1 ] && echo "Failed repairing $LOCALE"
  exit 1
fi

mv "$OUTPUT" "$LOCALE"
[ $VERBOSE -eq 1 ] && echo "Repaired $LOCALE"
exit 0
