# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `storable` gem.
# Please instead update this file by running `bin/tapioca gem storable`.


# source://storable//lib/storable.rb#26
class Boolean; end

# source://storable//lib/storable.rb#10
JSON_LOADED = T.let(T.unsafe(nil), TrueClass)

# Storable makes data available in multiple formats and can
# re-create objects from files. Fields are defined using the
# Storable.field method which tells Storable the order and
# name.
#
# source://storable//lib/storable.rb#33
class Storable
  extend ::Storable::DefaultProcessors

  # @return [Storable] a new instance of Storable
  #
  # source://storable//lib/storable.rb#227
  def initialize(*args); end

  # source://storable//lib/storable.rb#247
  def call(fname); end

  # Dump the object data to the given format.
  #
  # source://storable//lib/storable.rb#183
  def dump(format = T.unsafe(nil), with_titles = T.unsafe(nil)); end

  # Returns an array of field names defined by self.field
  #
  # source://storable//lib/storable.rb#170
  def field_names; end

  # Returns an array of field types defined by self.field. Fields that did
  # not receive a type are set to nil.
  #
  # source://storable//lib/storable.rb#175
  def field_types; end

  # This value will be used as a default unless provided on-the-fly.
  # See SUPPORTED_FORMATS for available values.
  #
  # source://storable//lib/storable.rb#149
  def format; end

  # See SUPPORTED_FORMATS for available values
  #
  # source://storable//lib/storable.rb#152
  def format=(v); end

  # source://storable//lib/storable.rb#231
  def from_array(*from); end

  # source://storable//lib/storable.rb#255
  def from_hash(from = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://storable//lib/storable.rb#142
  def has_field?(n); end

  # @return [Boolean]
  #
  # source://storable//lib/storable.rb#374
  def has_processor?(fname); end

  # source://storable//lib/storable.rb#223
  def init(*args); end

  # source://storable//lib/storable.rb#158
  def postprocess; end

  # source://storable//lib/storable.rb#370
  def process(fname, val); end

  # source://storable//lib/storable.rb#165
  def sensitive!; end

  # @return [Boolean]
  #
  # source://storable//lib/storable.rb#161
  def sensitive?; end

  # source://storable//lib/storable.rb#178
  def sensitive_fields; end

  # source://storable//lib/storable.rb#338
  def to_array; end

  # Return the object data as a comma delimited string.
  # +with_titles+ specifiy whether to include field names (default: false)
  #
  # source://storable//lib/storable.rb#429
  def to_csv(with_titles = T.unsafe(nil)); end

  # Return the object data as a delimited string.
  # +with_titles+ specifiy whether to include field names (default: false)
  # +delim+ is the field delimiter.
  #
  # source://storable//lib/storable.rb#411
  def to_delimited(with_titles = T.unsafe(nil), delim = T.unsafe(nil)); end

  # Write the object data to the given file.
  #
  # source://storable//lib/storable.rb#205
  def to_file(file_path = T.unsafe(nil), with_titles = T.unsafe(nil)); end

  # Return the object data as a hash
  # +with_titles+ is ignored.
  #
  # source://storable//lib/storable.rb#321
  def to_hash; end

  # source://storable//lib/storable.rb#352
  def to_json(*from, &blk); end

  # source://storable//lib/storable.rb#190
  def to_string(*args); end

  # Return the object data as a tab delimited string.
  # +with_titles+ specifiy whether to include field names (default: false)
  #
  # source://storable//lib/storable.rb#424
  def to_tsv(with_titles = T.unsafe(nil)); end

  # source://storable//lib/storable.rb#365
  def to_yaml(*from, &blk); end

  class << self
    # source://storable//lib/storable.rb#477
    def append_file(path, content, flush = T.unsafe(nil)); end

    # Returns the value of attribute debug.
    #
    # source://storable//lib/storable.rb#45
    def debug; end

    # Sets the attribute debug
    #
    # @param value the value to set the attribute debug to.
    #
    # source://storable//lib/storable.rb#45
    def debug=(_arg0); end

    # Accepts field definitions in the one of the follow formats:
    #
    #     field :product
    #     field :product => Integer
    #     field :product do |val|
    #       # modify val before it's stored.
    #     end
    #
    # The order they're defined determines the order the will be output. The fields
    # data is available by the standard accessors, class.product and class.product= etc...
    # The value of the field will be cast to the type (if provided) when read from a file.
    # The value is not touched when the type is not provided.
    #
    # source://storable//lib/storable.rb#69
    def field(*args, &processor); end

    # Returns the value of attribute field_names.
    #
    # source://storable//lib/storable.rb#45
    def field_names; end

    # Sets the attribute field_names
    #
    # @param value the value to set the attribute field_names to.
    #
    # source://storable//lib/storable.rb#45
    def field_names=(_arg0); end

    # Returns the value of attribute field_opts.
    #
    # source://storable//lib/storable.rb#45
    def field_opts; end

    # Sets the attribute field_opts
    #
    # @param value the value to set the attribute field_opts to.
    #
    # source://storable//lib/storable.rb#45
    def field_opts=(_arg0); end

    # Returns the value of attribute field_types.
    #
    # source://storable//lib/storable.rb#45
    def field_types; end

    # Sets the attribute field_types
    #
    # @param value the value to set the attribute field_types to.
    #
    # source://storable//lib/storable.rb#45
    def field_types=(_arg0); end

    # source://storable//lib/storable.rb#238
    def from_array(*from); end

    # Create a new instance of the object from comma-delimited data.
    # +from+ a JSON string split into an array by line.
    #
    # source://storable//lib/storable.rb#439
    def from_csv(from = T.unsafe(nil), sensitive = T.unsafe(nil)); end

    # Create a new instance of the object from a delimited string.
    # +from+ a JSON string split into an array by line.
    # +delim+ is the field delimiter.
    #
    # source://storable//lib/storable.rb#446
    def from_delimited(from = T.unsafe(nil), delim = T.unsafe(nil), sensitive = T.unsafe(nil)); end

    # Create a new instance of the object using data from file.
    #
    # source://storable//lib/storable.rb#196
    def from_file(file_path, format = T.unsafe(nil)); end

    # Create a new instance of the object from a hash.
    #
    # source://storable//lib/storable.rb#214
    def from_hash(from = T.unsafe(nil)); end

    # Create a new instance of the object from a JSON string.
    # +from+ a YAML String or Array (split into by line).
    #
    # source://storable//lib/storable.rb#389
    def from_json(*from); end

    # Create a new instance from tab-delimited data.
    # +from+ a JSON string split into an array by line.
    #
    # source://storable//lib/storable.rb#434
    def from_tsv(from = T.unsafe(nil), sensitive = T.unsafe(nil)); end

    # Create a new instance of the object from YAML.
    # +from+ a YAML String or Array (split into by line).
    #
    # source://storable//lib/storable.rb#380
    def from_yaml(*from); end

    # @return [Boolean]
    #
    # source://storable//lib/storable.rb#139
    def has_field?(n); end

    # Passes along fields to inherited classes
    #
    # source://storable//lib/storable.rb#49
    def inherited(obj); end

    # source://storable//lib/storable.rb#462
    def read_file_to_array(path); end

    # @return [Boolean]
    #
    # source://storable//lib/storable.rb#134
    def sensitive_field?(name); end

    # Returns the value of attribute sensitive_fields.
    #
    # source://storable//lib/storable.rb#128
    def sensitive_fields(*args); end

    # Sets the attribute sensitive_fields
    #
    # @param value the value to set the attribute sensitive_fields to.
    #
    # source://storable//lib/storable.rb#45
    def sensitive_fields=(_arg0); end

    # source://storable//lib/storable.rb#473
    def write_file(path, content, flush = T.unsafe(nil)); end

    # source://storable//lib/storable.rb#481
    def write_or_append_file(write_or_append, path, content = T.unsafe(nil), flush = T.unsafe(nil)); end
  end
end

# source://storable//lib/storable.rb#492
class Storable::Anonymous
  # @return [Anonymous] a new instance of Anonymous
  #
  # source://storable//lib/storable.rb#493
  def initialize(from); end

  # source://storable//lib/storable.rb#496
  def [](key); end

  # source://storable//lib/storable.rb#499
  def method_missing(meth, *args); end
end

# These methods can be used by Storable objects as
# custom field processors.
#
# e.g.
#
#     class A < Storable
#       field :name => String, &hash_proc_processor
#     end
#
# source://storable//lib/storable.rb#517
module Storable::DefaultProcessors
  # If the object already has a value for +@id+
  # use it, otherwise return the current digest.
  #
  # This allows an object to have a preset ID.
  #
  # source://storable//lib/storable.rb#542
  def gibbler_id_processor; end

  # Replace a hash of Proc objects with a hash
  # of
  #
  # source://storable//lib/storable.rb#520
  def hash_proc_processor; end

  # source://storable//lib/storable.rb#531
  def proc_processor; end
end

# source://storable//lib/storable.rb#39
Storable::NICE_TIME_FORMAT = T.let(T.unsafe(nil), String)

# AUTHOR
#    jan molic /mig/at/1984/dot/cz/
#
# DESCRIPTION
#    Hash with preserved order and some array-like extensions
#    Public domain.
#
# THANKS
#    Andrew Johnson for his suggestions and fixes of Hash[],
#    merge, to_a, inspect and shift
#
# source://storable//lib/storable/orderedhash.rb#11
class Storable::OrderedHash < ::Hash
  # @return [OrderedHash] a new instance of OrderedHash
  #
  # source://storable//lib/storable/orderedhash.rb#30
  def initialize(*a, &b); end

  # source://storable//lib/storable/orderedhash.rb#43
  def ==(hsh2); end

  # source://storable//lib/storable/orderedhash.rb#38
  def []=(a, b); end

  # source://storable//lib/storable/orderedhash.rb#161
  def __class__; end

  # source://storable//lib/storable/orderedhash.rb#158
  def class; end

  # source://storable//lib/storable/orderedhash.rb#47
  def clear; end

  # source://storable//lib/storable/orderedhash.rb#51
  def delete(key); end

  # source://storable//lib/storable/orderedhash.rb#68
  def delete_if; end

  # source://storable//lib/storable/orderedhash.rb#63
  def each; end

  # source://storable//lib/storable/orderedhash.rb#55
  def each_key; end

  # source://storable//lib/storable/orderedhash.rb#63
  def each_pair; end

  # source://storable//lib/storable/orderedhash.rb#59
  def each_value; end

  # source://storable//lib/storable/orderedhash.rb#193
  def each_with_index; end

  # source://storable//lib/storable/orderedhash.rb#82
  def first; end

  # source://storable//lib/storable/orderedhash.rb#138
  def inspect; end

  # source://storable//lib/storable/orderedhash.rb#88
  def invert; end

  # source://storable//lib/storable/orderedhash.rb#79
  def keys; end

  # source://storable//lib/storable/orderedhash.rb#85
  def last; end

  # source://storable//lib/storable/orderedhash.rb#148
  def merge(hsh2); end

  # source://storable//lib/storable/orderedhash.rb#143
  def merge!(hsh2); end

  # Returns the value of attribute order.
  #
  # source://storable//lib/storable/orderedhash.rb#12
  def order; end

  # Sets the attribute order
  #
  # @param value the value to set the attribute order to.
  #
  # source://storable//lib/storable/orderedhash.rb#12
  def order=(_arg0); end

  def orig_store(_arg0, _arg1); end

  # source://storable//lib/storable/orderedhash.rb#126
  def pop; end

  # source://storable//lib/storable/orderedhash.rb#117
  def push(k, v); end

  # source://storable//lib/storable/orderedhash.rb#93
  def reject(&block); end

  # source://storable//lib/storable/orderedhash.rb#96
  def reject!(&block); end

  # source://storable//lib/storable/orderedhash.rb#100
  def replace(hsh2); end

  # dup doesn't take an argument
  # and there's no need for it here
  #
  # source://storable//lib/storable/orderedhash.rb#153
  def select; end

  # source://storable//lib/storable/orderedhash.rb#104
  def shift; end

  # source://storable//lib/storable/orderedhash.rb#38
  def store(a, b); end

  # source://storable//lib/storable/orderedhash.rb#34
  def store_only(a, b); end

  # source://storable//lib/storable/orderedhash.rb#130
  def to_a; end

  # source://storable//lib/storable/orderedhash.rb#135
  def to_s; end

  # Returns the value of attribute to_yaml_style.
  #
  # source://storable//lib/storable/orderedhash.rb#165
  def to_yaml_style; end

  # Sets the attribute to_yaml_style
  #
  # @param value the value to set the attribute to_yaml_style to.
  #
  # source://storable//lib/storable/orderedhash.rb#165
  def to_yaml_style=(_arg0); end

  # source://storable//lib/storable/orderedhash.rb#108
  def unshift(k, v); end

  # source://storable//lib/storable/orderedhash.rb#143
  def update(hsh2); end

  # source://storable//lib/storable/orderedhash.rb#74
  def values; end

  # source://storable//lib/storable/orderedhash.rb#191
  def yaml_inline!; end

  # source://storable//lib/storable/orderedhash.rb#166
  def yaml_inline=(bool); end

  class << self
    # source://storable//lib/storable/orderedhash.rb#15
    def [](*args); end
  end
end

# source://storable//lib/storable.rb#40
Storable::SUPPORTED_FORMATS = T.let(T.unsafe(nil), Array)

# source://storable//lib/storable.rb#34
Storable::USE_ORDERED_HASH = T.let(T.unsafe(nil), TrueClass)

# source://storable//lib/storable.rb#38
Storable::VERSION = T.let(T.unsafe(nil), String)

# source://storable//lib/storable.rb#3
YAJL_LOADED = T.let(T.unsafe(nil), TrueClass)
