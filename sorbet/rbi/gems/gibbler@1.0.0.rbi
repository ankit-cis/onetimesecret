# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `gibbler` gem.
# Please instead update this file by running `bin/tapioca gem gibbler`.


# source://gibbler//lib/gibbler.rb#4
GIBBLER_LIB_HOME = T.let(T.unsafe(nil), String)

# = Gibbler
#
# "Hola, Tanneritos"
#
# source://gibbler//lib/gibbler.rb#15
class Gibbler < ::String
  include ::Gibbler::Digest::InstanceMethods

  # Creates a digest from the given +input+. See Gibbler.digest.
  #
  # If only one argument is given and it's a digest, this will
  # simply create an instance of that digest. In other words,
  # it won't calculate a new digest based on that input.
  #
  # @return [Gibbler] a new instance of Gibbler
  #
  # source://gibbler//lib/gibbler.rb#218
  def initialize(*input); end

  # source://gibbler//lib/gibbler.rb#230
  def digest(*input); end

  # source://gibbler//lib/gibbler.rb#226
  def digest_type; end

  # Modify the digest type for this instance. See Gibbler.digest_type
  #
  # source://gibbler//lib/gibbler.rb#211
  def digest_type=(_arg0); end

  # Returns the value of attribute input.
  #
  # source://gibbler//lib/gibbler.rb#212
  def input; end

  class << self
    # Set to true for debug output (including all digest inputs)
    #
    # source://gibbler//lib/gibbler.rb#253
    def debug; end

    # Set to true for debug output (including all digest inputs)
    #
    # source://gibbler//lib/gibbler.rb#253
    def debug=(_arg0); end

    # Returns the current debug status (true or false)
    #
    # @return [Boolean]
    #
    # source://gibbler//lib/gibbler.rb#255
    def debug?; end

    # Returns the value of attribute default_base.
    #
    # source://gibbler//lib/gibbler.rb#21
    def default_base; end

    # Sets the attribute default_base
    #
    # @param value the value to set the attribute default_base to.
    #
    # source://gibbler//lib/gibbler.rb#21
    def default_base=(_arg0); end

    # The delimiter to use when joining Array values before creating a
    # new digest hash. The default is ":".
    #
    # source://gibbler//lib/gibbler.rb#251
    def delimiter; end

    # The delimiter to use when joining Array values before creating a
    # new digest hash. The default is ":".
    #
    # source://gibbler//lib/gibbler.rb#251
    def delimiter=(_arg0); end

    # Sends +input+ to Digest::SHA1.hexdigest. If another digest class
    # has been specified, that class will be used instead.
    # If Gibbler.secret is set, +str+ will be prepended with the
    # value.
    #
    # If +input+ is an Array, it will be flattened and joined.
    #
    # See: digest_type
    #
    # source://gibbler//lib/gibbler.rb#266
    def digest(input, digest_type = T.unsafe(nil)); end

    # Specify a different digest class. The default is +Digest::SHA1+. You
    # could try +Digest::SHA256+ by doing this:
    #
    #     Object.digest_type = Digest::SHA256
    #
    # source://gibbler//lib/gibbler.rb#248
    def digest_type; end

    # Specify a different digest class. The default is +Digest::SHA1+. You
    # could try +Digest::SHA256+ by doing this:
    #
    #     Object.digest_type = Digest::SHA256
    #
    # source://gibbler//lib/gibbler.rb#248
    def digest_type=(_arg0); end

    # source://gibbler//lib/gibbler.rb#276
    def gibbler_debug(*args); end

    # Raises an exception. The correct usage is to include a Gibbler::Object:
    # * Gibbler::Complex
    # * Gibbler::String
    # * Gibbler::Object
    # * etc ...
    #
    # source://gibbler//lib/gibbler.rb#286
    def included(obj); end

    # Returns the value of attribute secret.
    #
    # source://gibbler//lib/gibbler.rb#21
    def secret; end

    # Sets the attribute secret
    #
    # @param value the value to set the attribute secret to.
    #
    # source://gibbler//lib/gibbler.rb#21
    def secret=(_arg0); end
  end
end

# Creates a digest based on:
# * parse each element into an Array of digests like: `CLASS:INDEX:VALUE.__gibbler`
#   * The gibbler method is called on each element so if it is a Hash or Array etc it
#     will be parsed recursively according to the gibbler method for that class type.
# * Digest the Array of digests
# * Return the digest for `class:length:value` where:
#   * "class" is equal to the current object class (e.g. Array).
#   * "length" is the size of the Array of digests (which should equal
#     the number of elements in the original Array object).
#   * "value" is the Array of digests joined with a colon (":").
#
# This method can be used by any class with an `each` method.
#
#     class MyNamedArray
#       include Gibbler::Array
#     end
#
# source://gibbler//lib/gibbler.rb#466
module Gibbler::Array
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  extend ::Attic
  include ::Attic::InstanceMethods

  mixes_in_class_methods ::Attic

  # Creates a digest for the current state of self.
  #
  # source://gibbler//lib/gibbler.rb#475
  def __gibbler(digest_type = T.unsafe(nil)); end

  # source://attic/1.0.1/lib/attic.rb#191
  def gibbler_cache; end

  # source://attic/1.0.1/lib/attic.rb#197
  def gibbler_cache=(val); end

  class << self
    # @private
    #
    # source://gibbler//lib/gibbler.rb#469
    def included(obj); end

    # source://attic/1.0.1/lib/attic.rb#144
    def inherited(klass); end
  end
end

# Creates a digest based on:
# * An Array of instance variable names or method names and values in the format: `CLASS:LENGTH:VALUE`
#   * The gibbler method is called on each element so if it is a Hash or Array etc it
#     will be parsed recursively according to the gibbler method for that class type.
# * Digest the Array of digests
# * Return the digest for `class:length:value` where:
#   * "class" is equal to the current object class (e.g. FullHouse).
#   * "length" is the size of the Array of digests (which should equal
#     the number of instance variables in the object).
#   * "value" is the Array of digests joined with a colon (":").
#
# This method can be used by any class which stores values in instance variables.
#
#     class Episodes
#       include Gibbler::Complex
#       attr_accessor :season, :year, :cast
#     end
#
# source://gibbler//lib/gibbler.rb#309
module Gibbler::Complex
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  extend ::Attic
  include ::Attic::InstanceMethods

  mixes_in_class_methods ::Attic

  # Creates a digest for the current state of self.
  #
  # source://gibbler//lib/gibbler.rb#345
  def __gibbler(digest_type = T.unsafe(nil)); end

  # source://gibbler//lib/gibbler.rb#363
  def __gibbler_revert!; end

  # source://attic/1.0.1/lib/attic.rb#191
  def gibbler_cache; end

  # source://attic/1.0.1/lib/attic.rb#197
  def gibbler_cache=(val); end

  # source://gibbler//lib/gibbler.rb#334
  def gibbler_fields; end

  class << self
    # @private
    #
    # source://gibbler//lib/gibbler.rb#312
    def included(obj); end

    # source://attic/1.0.1/lib/attic.rb#144
    def inherited(klass); end
  end
end

# Creates a digest based on: `CLASS:LENGTH:DATETIME`.
# Dates are calculated based on the equivalent datetime in UTC.
# e.g.
#
#     DateTime.parse('2009-08-25T17:00:40+00:00')  => ad64c769
#     DateTime.parse('2009-08-25T13:00:40-04:00')  => ad64c769
#
# To use use method in other classes simply:
#
#     class ClassLikeTime
#       include Gibbler::Time
#     end
#
# source://gibbler//lib/gibbler.rb#537
module Gibbler::DateTime
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  extend ::Attic
  include ::Attic::InstanceMethods

  mixes_in_class_methods ::Attic

  # Creates a digest for the current state of self.
  #
  # source://gibbler//lib/gibbler.rb#546
  def __gibbler(digest_type = T.unsafe(nil)); end

  # source://attic/1.0.1/lib/attic.rb#191
  def gibbler_cache; end

  # source://attic/1.0.1/lib/attic.rb#197
  def gibbler_cache=(val); end

  class << self
    # @private
    #
    # source://gibbler//lib/gibbler.rb#540
    def included(obj); end

    # source://attic/1.0.1/lib/attic.rb#144
    def inherited(klass); end
  end
end

# = Gibbler::Digest
#
# A tiny subclass of String which adds a
# few digest related convenience methods.
#
# source://gibbler//lib/gibbler.rb#34
class Gibbler::Digest < ::String
  include ::Gibbler::Digest::InstanceMethods
end

# source://gibbler//lib/gibbler.rb#36
module Gibbler::Digest::InstanceMethods
  # Returns true when +ali+ matches +self+
  #
  #    "kimmy".gibbler == "c8027100ecc54945ab15ddac529230e38b1ba6a1"  # => true
  #    "kimmy".gibbler == "c8027100"                                  # => false
  #
  # source://gibbler//lib/gibbler.rb#101
  def ==(ali); end

  # Returns true when +g+ matches one of: +self+, +short+, +shorter+, +tiny+
  #
  #    "kimmy".gibbler === "c8027100ecc54945ab15ddac529230e38b1ba6a1" # => true
  #    "kimmy".gibbler === "c8027100"                                 # => true
  #    "kimmy".gibbler === "c80271"                                   # => true
  #    "kimmy".gibbler === "c802"                                     # => true
  #
  # source://gibbler//lib/gibbler.rb#113
  def ===(g); end

  # source://gibbler//lib/gibbler.rb#48
  def base(base = T.unsafe(nil)); end

  # source://gibbler//lib/gibbler.rb#54
  def base36; end

  # Returns the first 8 characters of itself (the digest).
  #
  # e.g.
  #
  #     "kimmy".gibbler         # => c8027100ecc54945ab15ddac529230e38b1ba6a1
  #     "kimmy".gibbler.short   # => c8027100
  #
  # source://gibbler//lib/gibbler.rb#70
  def short; end

  # Shorten the digest to the given (optional) length.
  #
  # source://gibbler//lib/gibbler.rb#59
  def shorten(len = T.unsafe(nil)); end

  # Returns the first 6 characters of itself (the digest).
  #
  # e.g.
  #
  #     "kimmy".gibbler         # => c8027100ecc54945ab15ddac529230e38b1ba6a1
  #     "kimmy".gibbler.shorter # => c80271
  #
  # source://gibbler//lib/gibbler.rb#81
  def shorter; end

  # Returns the first 4 characters of itself (the digest).
  #
  # e.g.
  #
  #     "kimmy".gibbler         # => c8027100ecc54945ab15ddac529230e38b1ba6a1
  #     "kimmy".gibbler.tiny    # => c802
  #
  # source://gibbler//lib/gibbler.rb#92
  def tiny; end

  # Return an integer assuming base is Gibbler.default_base.
  #
  # source://gibbler//lib/gibbler.rb#38
  def to_i(base = T.unsafe(nil)); end

  # Returns a string. Takes an optional base.
  #
  # source://gibbler//lib/gibbler.rb#44
  def to_s(base = T.unsafe(nil)); end
end

# source://gibbler//lib/gibbler.rb#24
class Gibbler::Error < ::RuntimeError
  # @return [Error] a new instance of Error
  #
  # source://gibbler//lib/gibbler.rb#25
  def initialize(obj); end
end

# Creates a digest based on: `CLASS:PATHLENGTH:PATH`
# where PATHLENGTH is the length of the PATH string. PATH is
# not modified in any way (it is not converted to an absolute
# path).
#
# NOTE: You may expect this method to include other information
# like the file contents and modified date (etc...). The reason
# we do not is because Gibbler is concerned only about Ruby and
# not the outside world. There are many complexities in parsing
# file data and attributes which would make it difficult to run
# across platforms and Ruby versions / engines. If you want to
#
# e.g.
#
#    File.new('.')        # => c8bc8b3a
#    File.new('/tmp')     # => 3af85a19
#    File.new('/tmp/')    # => 92cbcb7d
#
# source://gibbler//lib/gibbler.rb#635
module Gibbler::File
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  extend ::Attic
  include ::Attic::InstanceMethods

  mixes_in_class_methods ::Attic

  # Creates a digest for the current state of self.
  #
  # source://gibbler//lib/gibbler.rb#644
  def __gibbler(digest_type = T.unsafe(nil)); end

  # source://attic/1.0.1/lib/attic.rb#191
  def gibbler_cache; end

  # source://attic/1.0.1/lib/attic.rb#197
  def gibbler_cache=(val); end

  class << self
    # @private
    #
    # source://gibbler//lib/gibbler.rb#638
    def included(obj); end

    # source://attic/1.0.1/lib/attic.rb#144
    def inherited(klass); end
  end
end

# Creates a digest based on:
# * parse each key, value pair into an Array containing keys: `CLASS:KEY:VALUE.__gibbler`
#   * The gibbler method is called on each element so if it is a Hash or Array etc it
#     will be parsed recursively according to the gibbler method for that class type.
# * Digest the Array of digests
# * Return the digest for `class:length:value` where:
#   * "class" is equal to the current object class (e.g. Hash).
#   * "length" is the size of the Array of digests (which should equal
#     the number of keys in the original Hash object).
#   * "value" is the Array of digests joined with a colon (":").
#
# This method can be used by any class with a `keys` method.
#
#     class MyOrderedHash
#       include Gibbler::Hash
#     end
#
# source://gibbler//lib/gibbler.rb#422
module Gibbler::Hash
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  extend ::Attic
  include ::Attic::InstanceMethods

  mixes_in_class_methods ::Attic

  # Creates a digest for the current state of self.
  #
  # source://gibbler//lib/gibbler.rb#431
  def __gibbler(digest_type = T.unsafe(nil)); end

  # source://attic/1.0.1/lib/attic.rb#191
  def gibbler_cache; end

  # source://attic/1.0.1/lib/attic.rb#197
  def gibbler_cache=(val); end

  class << self
    # @private
    #
    # source://gibbler//lib/gibbler.rb#425
    def included(obj); end

    # source://attic/1.0.1/lib/attic.rb#144
    def inherited(klass); end
  end
end

# Creates a digest based on: `CLASS:\0`
#
# e.g.
#
#     nil.gibbler      # => 06fdf26b
#
# source://gibbler//lib/gibbler.rb#600
module Gibbler::Nil
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  extend ::Attic
  include ::Attic::InstanceMethods

  mixes_in_class_methods ::Attic

  # Creates a digest for the current state of self.
  #
  # source://gibbler//lib/gibbler.rb#609
  def __gibbler(digest_type = T.unsafe(nil)); end

  # source://attic/1.0.1/lib/attic.rb#191
  def gibbler_cache; end

  # source://attic/1.0.1/lib/attic.rb#197
  def gibbler_cache=(val); end

  class << self
    # @private
    #
    # source://gibbler//lib/gibbler.rb#603
    def included(obj); end

    # source://attic/1.0.1/lib/attic.rb#144
    def inherited(klass); end
  end
end

# source://gibbler//lib/gibbler.rb#122
module Gibbler::Object
  include ::Attic::InstanceMethods

  mixes_in_class_methods ::Attic

  # Creates a digest for the current state of self based on:
  # * Object#class
  # * Length of Object#name || 0
  # * Object#name || ''
  #
  # e.g. Digest::SHA1.hexdigest "Class:6:Object" #=>
  #
  # <b>This is a default method appropriate for only the most
  # basic objects like Class and Module.</b>
  #
  # source://gibbler//lib/gibbler.rb#184
  def __gibbler(digest_type = T.unsafe(nil)); end

  # A simple override on Object#freeze to create a digest
  # before the object is frozen. Once the object is frozen
  # `obj.gibbler` will return the cached value with
  # out calculation.
  #
  # source://gibbler//lib/gibbler.rb#197
  def freeze; end

  # Has this object been modified?
  #
  # This method compares the return value from digest with the
  # previous value returned by gibbler (the value is stored in
  # the attic as `gibbler_cache`).
  # See Attic[http://github.com/delano/attic]
  #
  # @return [Boolean]
  #
  # source://gibbler//lib/gibbler.rb#162
  def gibbled?; end

  # Calculates a digest for the current object instance.
  # Objects that are a kind of Hash or Array are processed
  # recursively. The length of the returned String depends
  # on the digest type. Also stores the value in the attic.
  #
  #     obj.gibbler          # => a5b1191a
  #     obj.gibbler_cache    # => a5b1191a
  #
  # Calling gibbler_cache returns the most recent digest
  # without calculation.
  #
  # If the object is frozen, this will return the value of
  # `gibbler_cache`.
  #
  # source://gibbler//lib/gibbler.rb#148
  def gibbler(digest_type = T.unsafe(nil)); end

  # source://gibbler//lib/gibbler.rb#169
  def gibbler_debug(*args); end

  # source://gibbler//lib/gibbler.rb#131
  def gibbler_fields; end

  class << self
    # source://gibbler//lib/gibbler.rb#129
    def gibbler_fields; end

    # @private
    #
    # source://gibbler//lib/gibbler.rb#124
    def included(obj); end
  end
end

# Creates a digest based on: `CLASS:EXCLUDE?:FIRST:LAST`
# where EXCLUDE? is a boolean value whether the Range excludes
# the last value (i.e. 1...100) and FIRST and LAST are the values
# returned by Range#first and Range#last.
# e.g.
#
#     (1..100)   =>  Range:false:1:100  =>  54506352
#     (1...100)  =>  Range:true:1:100   =>  f0cad8cc
#
# To use use method in other classes simply:
#
#     class ClassLikeRange
#       include Gibbler::Range
#     end
#
# source://gibbler//lib/gibbler.rb#571
module Gibbler::Range
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  extend ::Attic
  include ::Attic::InstanceMethods

  mixes_in_class_methods ::Attic

  # Creates a digest for the current state of self.
  #
  # source://gibbler//lib/gibbler.rb#580
  def __gibbler(digest_type = T.unsafe(nil)); end

  # source://attic/1.0.1/lib/attic.rb#191
  def gibbler_cache; end

  # source://attic/1.0.1/lib/attic.rb#197
  def gibbler_cache=(val); end

  class << self
    # @private
    #
    # source://gibbler//lib/gibbler.rb#574
    def included(obj); end

    # source://attic/1.0.1/lib/attic.rb#144
    def inherited(klass); end
  end
end

# Creates a digest based on: `CLASS:LENGTH:VALUE`.
# This method can be used for any class where the `to_s`
# method returns an appropriate unique value for this instance.
# It's used by default for Symbol, Class, Integer.
# e.g.
#
#     "str" => String:3:str => 509a839ca1744c72e37759e7684ff0daa3b61427
#     :sym  => Symbol:3:sym => f3b7b3ca9529002c6826b1ef609d3583c356c8c8
#
# To use use method in other classes simply:
#
#     class MyStringLikeClass
#       include Gibbler::String
#     end
#
# source://gibbler//lib/gibbler.rb#387
module Gibbler::String
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  extend ::Attic
  include ::Attic::InstanceMethods

  mixes_in_class_methods ::Attic

  # Creates a digest for the current state of self.
  #
  # source://gibbler//lib/gibbler.rb#396
  def __gibbler(digest_type = T.unsafe(nil)); end

  # source://attic/1.0.1/lib/attic.rb#191
  def gibbler_cache; end

  # source://attic/1.0.1/lib/attic.rb#197
  def gibbler_cache=(val); end

  class << self
    # @private
    #
    # source://gibbler//lib/gibbler.rb#390
    def included(obj); end

    # source://attic/1.0.1/lib/attic.rb#144
    def inherited(klass); end
  end
end

# Creates a digest based on: `CLASS:LENGTH:TIME`.
# Times are calculated based on the equivalent time in UTC.
# e.g.
#
#     Time.parse('2009-08-25 16:43:53 UTC')     => 73b4635f
#     Time.parse('2009-08-25 12:43:53 -04:00')  => 73b4635f
#
# To use use method in other classes simply:
#
#     class ClassLikeTime
#       include Gibbler::Time
#     end
#
# source://gibbler//lib/gibbler.rb#506
module Gibbler::Time
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  extend ::Attic
  include ::Attic::InstanceMethods

  mixes_in_class_methods ::Attic

  # Creates a digest for the current state of self.
  #
  # source://gibbler//lib/gibbler.rb#515
  def __gibbler(digest_type = T.unsafe(nil)); end

  # source://attic/1.0.1/lib/attic.rb#191
  def gibbler_cache; end

  # source://attic/1.0.1/lib/attic.rb#197
  def gibbler_cache=(val); end

  class << self
    # @private
    #
    # source://gibbler//lib/gibbler.rb#509
    def included(obj); end

    # source://attic/1.0.1/lib/attic.rb#144
    def inherited(klass); end
  end
end

# source://gibbler//lib/gibbler.rb#655
class String
  include ::Comparable
end
